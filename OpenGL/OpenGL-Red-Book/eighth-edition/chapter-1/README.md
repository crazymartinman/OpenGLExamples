

### What is OpenGL?
OpenGL is an application programming interface (API), it is a software library for accessing features in graphics hardware.
In OpenGL, you must construct your three-dimensional objects from a small set of geometric primitives - points, lines, 
triangles, ang patches. OpenGL was first developed at Silicon Graphics Computer Systems with Version 1.0 released July of
1994.

The following is a list of brief operations that an OpenGL application would perform to render an image:
* Specify the data for constructing shapes from OpenGL's geometric primitives.
* Execute various shaders to perform calculations on the input primitives to determine their position, color, and other rendering attributes.
* Convert the mathematical description of the input primitives into their fragments associated with locations on the screen. This process is called rasterization.
* Finally, execute a fragment shader for each of the fragments generated by rasterization, which will determine the fragment's final color and position.
* Possibly perform additional per-fragment operations such as determining if the object that the fragment was generated from is visible, or blending the fragment's color with the current color in that screen locate.

OpenGL is implemented as a client-server system, with the applications written by developers being considered the client,
and the OpenGL implementation provided by the manufacturer of your computer graphics hardware being the server.

### Your First look at an OpenGL Program
The basic structure of all OpenGL applications is usually similar to the following:
* Initialize the state associated with how objects should be rendered.
* Specify those objects to be rendered.

Before we look at some code, we are going to introduce some graphics terminology. The term "rendering", is the process
by which a copmuter creates an image from models. OpenGL is just one example of a rendering system - OpenGL is a 
rasterization-based system, but there are other methods for generating images as well, such as ray tracing; however, 
even a system that uses ray tracing may employ OpenGL to display an image, or compute information to be used in creating
an image.

Our "models", or "objects" - we will use the terms interchangably - are constructed from geometric primitives - points,
lines, and triangles - that are specified by their vertices.

Another concept that is essential to using OpenGL is shaders, which are special functions that the graphics hardware executes.
The best way to think of shaders is as little programs that are specifically compiled for your graphics processing unit - 
commonly called a graphics processing unit (GPU). OpenGL includes all the compiler tool internally to take the source code of
your shader and create the code that the GPU needs to execute. In OpenGL, there are four shader stages that you can use. The 
most common are vertex shaders, which process vertex data, and fragment shaders, which operate on the fragments generated by
the rasterizer. Both vertex and fragment shaders are required in every OpenGL program.

The final generated image consist of pixels drawn on the screen; a pixel is the smallest visible element on your display. The
pixels in your system are stored in a framebuffer, which is a chunk of memory that the graphics hardware manages, and feeds to
your display device.

### Dissecting first example
This is just a disclaimer, the source code provided in the book was not complete and difficult to get started. I have re-written
portions of the code in order to get them working with libraries that regularly used at this particular point in time; however,
in the future it would be nice to remove these libraries and write a basic platform specific code to handle all of the setup
task. 

For this example we are using statically compiled version of [glew][glew-lib] and [glfw][glfw-lib]. Personally, I am not too 
familiar with these libraries at this particular point in time, so please feel free to open pull request to correct anything
that I might be missing.

Folder structure for example-1:
```plain
- example-1
  - lib
    + glew32s.lib
    + glfw3.lib
  + eglew.h
  + glew.h
  + glfw.h
  + glfw3native.h
  + glxew.h
  + wglew.h
  + main.cpp
  + build.bat
  + triangles.frag
  + triangles.vert
```

MSVC build script (build.bat):
```batch
IF NOT EXIST .\build mkdir .\build
pushd .\build

cl -Od -MD -nologo -Zi ..\main.cpp /link -incremental:no -opt:ref /LIBPATH:..\lib glew32s.lib glfw3.lib opengl32.lib glu32.lib user32.lib gdi32.lib shell32.lib

dir

popd

copy triangles.vert .\build
copy trinagles.frag .\build
```

```C
#include <iostream>

#define GLEW_STATIC

#include "glew.h"
#include "glfw3.h"

#define BUFFER_OFFSET(a) ((void *)(a))

void init(void);
void display(void);
static const GLchar* ReadShader(const char *);

enum VAO_IDs
{
	Triangles = 0,
	NumVAOs = 1
};

enum Buffer_IDs 
{
	ArrayBuffer = 0,
	NumBuffers = 1
};

enum Attrib_IDs
{
	vPosition = 0
};

GLuint VAOs[NumVAOs];
GLuint Buffers[NumBuffers];

const GLuint NumVertices = 6;

int main(int argc, char *argv[])
{
	GLFWwindow *window;

	if (!glfwInit())
	{
		return -1;
	}

	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);

	if (glewInit())
	{
		glfwTerminate();
		return -1;
	}

	init();

	while (!glfwWindowShouldClose(window))
	{
		display();
		glfwSwapBuffers(window);
		glfwPollEvents();
	}
	
	glfwTerminate();

	return 0;
}

void init(void)
{
	glGenVertexArrays(NumVAOs, VAOs);
	glBindVertexArray(VAOs[Triangles]);

	GLfloat vertices[NumVertices][2] =
	{
		// Triangle One
		{ -0.90f, -0.90f },
		{  0.85f, -0.90f }, 
		{ -0.90f,  0.85f },
		// Triangle Two
		{  0.90f, -0.80f },
		{  0.90f,  0.90f },
		{ -0.85f,  0.90f }
	};

	glGenBuffers(NumBuffers, Buffers);
	glBindBuffer(GL_ARRAY_BUFFER, Buffers[ArrayBuffer]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

	GLuint GLProgram = glCreateProgram();

	// NOTE(nick): vertex shader
	GLuint Vertex_Shader = glCreateShader(GL_VERTEX_SHADER);
	const GLchar *source = ReadShader(".\\triangles.vert");

	glShaderSource(Vertex_Shader, 1, &source, NULL); 

	glCompileShader(Vertex_Shader);

	GLint compiled;

	glGetShaderiv(Vertex_Shader, GL_COMPILE_STATUS, &compiled);

	if (!compiled)
	{
		GLsizei len;
		glGetShaderiv(Vertex_Shader, GL_INFO_LOG_LENGTH, &len);

		GLchar *log = new GLchar[len + 1];
		glGetShaderInfoLog(Vertex_Shader, len, &len, log);

		std::cerr << log << std::endl;

		delete [] log;
	}

	glAttachShader(GLProgram, Vertex_Shader);

	// NOTE(nick): fragment shader
	GLuint Fragment_Shader = glCreateShader(GL_FRAGMENT_SHADER);
	source = ReadShader(".\\triangles.frag");

	glShaderSource(Fragment_Shader, 1, &source, NULL); 

	glCompileShader(Fragment_Shader);

	glGetShaderiv(Fragment_Shader, GL_COMPILE_STATUS, &compiled);

	if (!compiled)
	{
		GLsizei len;
		glGetShaderiv(Fragment_Shader, GL_INFO_LOG_LENGTH, &len);

		GLchar *log = new GLchar[len + 1];
		glGetShaderInfoLog(Fragment_Shader, len, &len, log);

		std::cerr << log << std::endl;

		delete [] log;
	}

	glAttachShader(GLProgram, Fragment_Shader);

	glLinkProgram(GLProgram);

	GLint linked;

	glGetProgramiv(GLProgram, GL_LINK_STATUS, &linked);

	if (!linked)
	{
	        GLsizei len;
	        glGetProgramiv(GLProgram, GL_INFO_LOG_LENGTH, &len);

	        GLchar* log = new GLchar[len + 1];
        	glGetProgramInfoLog(GLProgram, len, &len, log);

		std::cerr << log << std::endl;

        	delete [] log;
	}

	delete [] source;

	glUseProgram(GLProgram);
	
	glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
	glEnableVertexAttribArray(vPosition);
}

void display(void)
{
	static const float black[] = { 0.0f, 0.0f, 0.0f, 0.0f };

	glClearBufferfv(GL_COLOR, 0, black);

	glBindVertexArray(VAOs[Triangles]);
	glDrawArrays(GL_TRIANGLES, 0, NumVertices);
}

static const GLchar* ReadShader(const char *filename)
{
	FILE *InFile;
	fopen_s(&InFile, filename, "rb");

	if (!InFile) 
	{
		std::cerr << filename << std::endl;
	}

	fseek(InFile, 0, SEEK_END);
	int len = ftell(InFile);
	fseek(InFile, 0, SEEK_SET);

	GLchar *source = new GLchar[len + 1];

	fread(source, 1, len, InFile);
	fclose(InFile);

	source[len] = 0;

	return const_cast<const GLchar *>(source);
}
```

[glew-lib]: 	http://glew.sourceforge.net/
[glfw-lib]:	http://www.glfw.org/
