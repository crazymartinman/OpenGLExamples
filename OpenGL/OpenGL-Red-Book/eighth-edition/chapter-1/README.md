

### What is OpenGL?
OpenGL is an application programming interface (API), it is a software library for accessing features in graphics hardware.
In OpenGL, you must construct your three-dimensional objects from a small set of geometric primitives - points, lines, 
triangles, ang patches. OpenGL was first developed at Silicon Graphics Computer Systems with Version 1.0 released July of
1994.

The following is a list of brief operations that an OpenGL application would perform to render an image:
* Specify the data for constructing shapes from OpenGL's geometric primitives.
* Execute various shaders to perform calculations on the input primitives to determine their position, color, and other rendering attributes.
* Convert the mathematical description of the input primitives into their fragments associated with locations on the screen. This process is called rasterization.
* Finally, execute a fragment shader for each of the fragments generated by rasterization, which will determine the fragment's final color and position.
* Possibly perform additional per-fragment operations such as determining if the object that the fragment was generated from is visible, or blending the fragment's color with the current color in that screen locate.

OpenGL is implemented as a client-server system, with the applications written by developers being considered the client,
and the OpenGL implementation provided by the manufacturer of your computer graphics hardware being the server.

### Your First look at an OpenGL Program
The basic structure of all OpenGL applications is usually similar to the following:
* Initialize the state associated with how objects should be rendered.
* Specify those objects to be rendered.

Before we look at some code, we are going to introduce some graphics terminology. The term "rendering", is the process
by which a copmuter creates an image from models. OpenGL is just one example of a rendering system - OpenGL is a 
rasterization-based system, but there are other methods for generating images as well, such as ray tracing; however, 
even a system that uses ray tracing may employ OpenGL to display an image, or compute information to be used in creating
an image.

Our "models", or "objects" - we will use the terms interchangably - are constructed from geometric primitives - points,
lines, and triangles - that are specified by their vertices.

Another concept that is essential to using OpenGL is shaders, which are special functions that the graphics hardware executes.
The best way to think of shaders is as little programs that are specifically compiled for your graphics processing unit - 
commonly called a graphics processing unit (GPU). OpenGL includes all the compiler tool internally to take the source code of
your shader and create the code that the GPU needs to execute. In OpenGL, there are four shader stages that you can use. The 
most common are vertex shaders, which process vertex data, and fragment shaders, which operate on the fragments generated by
the rasterizer. Both vertex and fragment shaders are required in every OpenGL program.

The final generated image consist of pixels drawn on the screen; a pixel is the smallest visible element on your display. The
pixels in your system are stored in a framebuffer, which is a chunk of memory that the graphics hardware manages, and feeds to
your display device.

### Dissecting first example
This is just a disclaimer, the source code provided in the book was not complete and difficult to get started. I have re-written
portions of the code in order to get them working with libraries that regularly used at this particular point in time; however,
in the future it would be nice to remove these libraries and write a basic platform specific code to handle all of the setup
task. 

For this example we are using statically compiled version of [glew][glew-lib] and [glfw][glfw-lib]. Personally, I am not too 
familiar with these libraries at this particular point in time, so please feel free to open pull request to correct anything
that I might be missing.

Folder structure for example-1:
```plain
- example-1
  - lib
    + glew32s.lib
    + glfw3.lib
  + eglew.h
  + glew.h
  + glfw.h
  + glfw3native.h
  + glxew.h
  + wglew.h
  + main.cpp
  + build.bat
  + triangles.frag
  + triangles.vert
```

MSVC build script (build.bat):
```batch
IF NOT EXIST .\build mkdir .\build
pushd .\build

cl -Od -MD -nologo -Zi ..\main.cpp /link -incremental:no -opt:ref /LIBPATH:..\lib glew32s.lib glfw3.lib opengl32.lib glu32.lib user32.lib gdi32.lib shell32.lib

dir

popd

copy triangles.vert .\build
copy trinagles.frag .\build
```

```C
#include <iostream>

#define GLEW_STATIC

#include "glew.h"
#include "glfw3.h"

#define BUFFER_OFFSET(a) ((void *)(a))

void init(void);
void display(void);
static const GLchar* ReadShader(const char *);

enum VAO_IDs
{
	Triangles = 0,
	NumVAOs = 1
};

enum Buffer_IDs 
{
	ArrayBuffer = 0,
	NumBuffers = 1
};

enum Attrib_IDs
{
	vPosition = 0
};

GLuint VAOs[NumVAOs];
GLuint Buffers[NumBuffers];

const GLuint NumVertices = 6;

int main(int argc, char *argv[])
{
	GLFWwindow *window;

	if (!glfwInit())
	{
		return -1;
	}

	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);

	if (glewInit())
	{
		glfwTerminate();
		return -1;
	}

	init();

	while (!glfwWindowShouldClose(window))
	{
		display();
		glfwSwapBuffers(window);
		glfwPollEvents();
	}
	
	glfwTerminate();

	return 0;
}

void init(void)
{
	glGenVertexArrays(NumVAOs, VAOs);
	glBindVertexArray(VAOs[Triangles]);

	GLfloat vertices[NumVertices][2] =
	{
		// Triangle One
		{ -0.90f, -0.90f },
		{  0.85f, -0.90f }, 
		{ -0.90f,  0.85f },
		// Triangle Two
		{  0.90f, -0.80f },
		{  0.90f,  0.90f },
		{ -0.85f,  0.90f }
	};

	glGenBuffers(NumBuffers, Buffers);
	glBindBuffer(GL_ARRAY_BUFFER, Buffers[ArrayBuffer]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

	GLuint GLProgram = glCreateProgram();

	// NOTE(nick): vertex shader
	GLuint Vertex_Shader = glCreateShader(GL_VERTEX_SHADER);
	const GLchar *source = ReadShader(".\\triangles.vert");

	glShaderSource(Vertex_Shader, 1, &source, NULL); 

	glCompileShader(Vertex_Shader);

	GLint compiled;

	glGetShaderiv(Vertex_Shader, GL_COMPILE_STATUS, &compiled);

	if (!compiled)
	{
		GLsizei len;
		glGetShaderiv(Vertex_Shader, GL_INFO_LOG_LENGTH, &len);

		GLchar *log = new GLchar[len + 1];
		glGetShaderInfoLog(Vertex_Shader, len, &len, log);

		std::cerr << log << std::endl;

		delete [] log;
	}

	glAttachShader(GLProgram, Vertex_Shader);

	// NOTE(nick): fragment shader
	GLuint Fragment_Shader = glCreateShader(GL_FRAGMENT_SHADER);
	source = ReadShader(".\\triangles.frag");

	glShaderSource(Fragment_Shader, 1, &source, NULL); 

	glCompileShader(Fragment_Shader);

	glGetShaderiv(Fragment_Shader, GL_COMPILE_STATUS, &compiled);

	if (!compiled)
	{
		GLsizei len;
		glGetShaderiv(Fragment_Shader, GL_INFO_LOG_LENGTH, &len);

		GLchar *log = new GLchar[len + 1];
		glGetShaderInfoLog(Fragment_Shader, len, &len, log);

		std::cerr << log << std::endl;

		delete [] log;
	}

	glAttachShader(GLProgram, Fragment_Shader);

	glLinkProgram(GLProgram);

	GLint linked;

	glGetProgramiv(GLProgram, GL_LINK_STATUS, &linked);

	if (!linked)
	{
	        GLsizei len;
	        glGetProgramiv(GLProgram, GL_INFO_LOG_LENGTH, &len);

	        GLchar* log = new GLchar[len + 1];
        	glGetProgramInfoLog(GLProgram, len, &len, log);

		std::cerr << log << std::endl;

        	delete [] log;
	}

	delete [] source;

	glUseProgram(GLProgram);
	
	glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
	glEnableVertexAttribArray(vPosition);
}

void display(void)
{
	static const float black[] = { 0.0f, 0.0f, 0.0f, 0.0f };

	glClearBufferfv(GL_COLOR, 0, black);

	glBindVertexArray(VAOs[Triangles]);
	glDrawArrays(GL_TRIANGLES, 0, NumVertices);
}

static const GLchar* ReadShader(const char *filename)
{
	FILE *InFile;
	fopen_s(&InFile, filename, "rb");

	if (!InFile) 
	{
		std::cerr << filename << std::endl;
	}

	fseek(InFile, 0, SEEK_END);
	int len = ftell(InFile);
	fseek(InFile, 0, SEEK_SET);

	GLchar *source = new GLchar[len + 1];

	fread(source, 1, len, InFile);
	fclose(InFile);

	source[len] = 0;

	return const_cast<const GLchar *>(source);
}
```
In a nutshell, here is what the example does:

* Include the appropriate header files and declare global variables and other useful programming constructs.
* The init() function is used to set up data for use later in the program. This may be vertex information for later use when rendering primitives, or image data for use in a technique called texture mapping.
* In the init() function, we first specify the position information for the two triangles that we render. After that, we specify shaders we are going to use in our program, load the shaders into memory, and compile them on the GPU. In this case, we only use the required vertex and fragment shaders. After each shader is compiled, it is attached to a GLProgram; additionally, after the needed shaders have been compiled and attached the GLProgram needs to be linked and then "used".
* The display() function is what does the rendering. That is, it calls the OpenGL functions that request something to be rendered. Almost all the display() function will do the same three steps as in our sample:
  1. Clear the window by calling glClear().
  2. Issue the OpenGL calls required to render your object.
  3. Request that the image is presented to the screen.
* Finally, the main() function does the heavy lifting of creating a window, calling the init() function, and finally entering into the event loop.

### OpenGL Syntax
All the functions in the OpenGL library begin with the letters "gl", immediately followed by one or more capitalized words to name the function (glBindVertexArray() function, for example).
All functions in OpenGL are like that; additionally, you will notice functions that beging with "glfw" that are related to the library [glfw][glfw-lib] and functions that begin with "glew"
that are related to the library [glew][glew-lib]. Similar to OpenGL's function-naming convention, constants like "GL_COLOR_BUFFER_BIT", which you saw in the function display(), are defined
for the OpenGL library. All constant tokens begin with "GL_", and use underscores to separate words. Their definitions are merely #defines found in the OpenGL header files: "glcorearb.h" and
"glext.h".

To aid in moving OpenGL applications between operating systems, OpenGL also defines various types of data for its functions, such as GLfloat, which is the floating-point value type we used to
declare vertices in the example. OpenGL defines typedefs for all of the data types accepted by its functions; additionally, since OpenGL is a "C"-language library, it does not have function
overloading to deal with the different types of data - instead it uses a function-naming convention to organize the multitude of functions that result from that situtation. For example,
we will ecounter a function named glUniform*() in Chapter 2, "Shader Fundamentals", which comes in numerous forms, such as glUniform2f() and glUniform3fv(). The suffixes at the end of the "core"
part of the function name provide information about the arguments passed to the function. For example, the "2" in glUniform2f() represents that two data values will be passed into the function.
Also, note the "f" following the "2" - this indicates that those two parameters are of type GLfloat. Finally, versions of the functions name end with a "v", which is short for "vector", meaning
that the two floating-point values (int the case of glUniform2fv()) are passed as a one-dimensional array GLfloats, instead of two separate parameters.

| Suffix        | Data Type               | Typical Corresponding C-Language Type  | OpenGL Type Definition 	|
| ------------- | ----------------------- | -------------------------------------- | -------------------------- |
| b 		| 8-bit integer	          | signed char 			   | GLbyte		    	|
| s 		| 16-bit integer          | signed short 		           | GLshort		    	|
| i 		| 32-bit integer          | int	 			       	   | GLint, GLsizei         	|
| f 		| 32-bit float-point      | float	 			   | GLfloat, GLclampf	    	|
| d 		| 64-bit float-point      | double	 			   | GLdouble, GLclampd	    	|
| ub 		| 8-bit unsigned integer  | unsigned char 	 		   | GLubyte		    	|
| us 		| 16-bit unsigned integer | unsigned short 	 		   | GLushort		        |
| ui 		| 32-bit unsigned integer | unsigned int 	 		   | GLuint, GLenum, GLbitfield |

### OpenGL's Rendering Pipeline
OpenGL implements a "rendering pipeline", which is a sequence of processing stages for converting the data your application provides to OpenGL into a final rendered image. Below is a overview
of how OpenGL pipeline associated with Version 4.3 works:

```plain
	Vertex Data -> Vertex shader -> Tesselation Control Shader -> Tesselation Evalutation Shader ---\
	/-----------------------------------------------------------------------------------------------|
	V
	Geometry Shader -> Primitive Setup -> Clipping -> Rasterization -> Fragment Shader -> "Output Image :)"
```

[glew-lib]: 	http://glew.sourceforge.net/
[glfw-lib]:	http://www.glfw.org/
